# translateAPI.py
import requests
import hashlib
import time
import uuid
import json
from typing import Optional, Dict, Any

#the API generated by Deepseek LLM

class YoudaoTranslator:
    """
    有道翻译API封装类
    
    使用说明：
    1. 用户需要在界面中输入有道API的应用ID和应用密钥
    2. 初始化时传入API Key和Keyfrom
    3. 调用translate方法进行翻译
    4. 每次启动都需要重新输入，不保存任何密钥到本地
    """
    
    def __init__(self, app_key: str = "", app_secret: str = ""):
        """
        初始化翻译器
        
        Args:
            app_key: 有道API的应用ID（用户输入）
            app_secret: 有道API的应用密钥（用户输入）
        """
        self.app_key = app_key
        self.app_secret = app_secret
        self.base_url = "https://openapi.youdao.com/api"
        
        # 验证API密钥格式（基本格式检查）
        self._validate_credentials()
    
    def _validate_credentials(self) -> None:
        """
        验证API密钥格式
        只做基本格式检查，不验证有效性
        """
        if self.app_key and len(self.app_key.strip()) < 10:
            print("警告: API Key格式可能不正确")
        if self.app_secret and len(self.app_secret.strip()) < 10:
            print("警告: API Secret格式可能不正确")
    
    def set_credentials(self, app_key: str, app_secret: str) -> None:
        """
        动态设置API凭证
        
        Args:
            app_key: 新的应用ID
            app_secret: 新的应用密钥
        """
        self.app_key = app_key
        self.app_secret = app_secret
        self._validate_credentials()
    
    def has_credentials(self) -> bool:
        """
        检查是否已设置API凭证
        
        Returns:
            bool: 是否已设置凭证
        """
        return bool(self.app_key and self.app_secret)
    
    def _generate_sign(self, text: str, salt: str, curtime: str) -> str:
        """
        生成API签名
        
        Args:
            text: 要翻译的文本
            salt: 随机字符串
            curtime: 当前时间戳
            
        Returns:
            str: 计算后的签名
        """
        if not self.has_credentials():
            raise ValueError("API凭证未设置")
        
        # 处理文本长度
        input_str = text
        if len(text) > 20:
            input_str = text[:10] + str(len(text)) + text[-10:]
        
        # 计算签名
        sign_str = self.app_key + input_str + salt + curtime + self.app_secret
        return hashlib.sha256(sign_str.encode('utf-8')).hexdigest()
    
    def translate(
        self, 
        text: str, 
        from_lang: str = "auto", 
        to_lang: str = "auto"
    ) -> Dict[str, Any]:
        """
        执行翻译
        
        Args:
            text: 要翻译的文本
            from_lang: 源语言代码，默认为auto（自动检测）
            to_lang: 目标语言代码，默认为auto（自动为目标语言）
            
        Returns:
            Dict: 包含翻译结果的字典，包含以下字段：
                - success: 是否成功
                - result: 翻译结果（成功时）
                - error: 错误信息（失败时）
                - raw_response: 原始API响应
                
        语言代码示例：
            auto - 自动检测
            zh-CHS - 中文
            en - 英文
            ja - 日文
            ko - 韩文
            fr - 法文
            de - 德文
            ru - 俄文
            es - 西班牙文
        """
        # 检查API凭证
        if not self.has_credentials():
            return {
                "success": False,
                "error": "请先设置API凭证（应用ID和应用密钥）",
                "raw_response": None
            }
        
        # 参数检查
        if not text or not text.strip():
            return {
                "success": False,
                "error": "翻译文本不能为空",
                "raw_response": None
            }
        
        try:
            # 准备请求参数
            salt = str(uuid.uuid4())
            curtime = str(int(time.time()))
            sign = self._generate_sign(text, salt, curtime)
            
            # 构建请求数据
            data = {
                'q': text,
                'from': from_lang,
                'to': to_lang,
                'appKey': self.app_key,
                'salt': salt,
                'sign': sign,
                'signType': 'v3',
                'curtime': curtime,
            }
            
            # 发送请求
            headers = {'Content-Type': 'application/x-www-form-urlencoded'}
            response = requests.post(self.base_url, data=data, headers=headers, timeout=10)
            
            # 解析响应
            result = response.json()
            
            # 检查错误码
            error_code = result.get('errorCode', '0')
            
            if error_code == '0':
                # 成功返回
                translation = result.get('translation', [])
                basic = result.get('basic', {})
                
                return {
                    "success": True,
                    "result": {
                        "original": text,
                        "translated": translation[0] if translation else "",
                        "phonetic": basic.get('phonetic', '') if basic else '',
                        "explains": basic.get('explains', []) if basic else [],
                        "web": result.get('web', []) if result.get('web') else []
                    },
                    "raw_response": result
                }
            else:
                # 错误处理
                error_map = {
                    '101': '缺少必填参数',
                    '102': '不支持的语言类型',
                    '103': '翻译文本过长',
                    '104': '不支持的API类型',
                    '105': '不支持的签名类型',
                    '106': '不支持的响应类型',
                    '107': '不支持的传输加密类型',
                    '108': '应用ID无效',
                    '109': 'batchLog格式不正确',
                    '110': '无相关有效结果',
                    '111': '开发者账号无效',
                    '112': '请求服务无效',
                    '113': '查询参数不能为空',
                    '201': '解密失败',
                    '202': '签名检验失败',
                    '203': '访问IP地址不在可访问IP列表',
                    '205': '请求的接口与应用的平台类型不一致',
                    '301': '辞典查询失败',
                    '302': '翻译查询失败',
                    '303': '服务端的其它异常',
                    '401': '账户已经欠费停',
                    '411': '访问频率受限,请稍后访问',
                    '412': '长请求过于频繁，请稍后访问'
                }
                
                error_msg = error_map.get(error_code, f"API返回错误 (错误码: {error_code})")
                return {
                    "success": False,
                    "error": error_msg,
                    "raw_response": result
                }
                
        except requests.exceptions.RequestException as e:
            return {
                "success": False,
                "error": f"网络请求失败: {str(e)}",
                "raw_response": None
            }
        except ValueError as e:
            # API凭证未设置的情况
            return {
                "success": False,
                "error": str(e),
                "raw_response": None
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"翻译过程出错: {str(e)}",
                "raw_response": None
            }
    
    def translate_text_only(
        self, 
        text: str, 
        from_lang: str = "auto", 
        to_lang: str = "auto"
    ) -> Optional[str]:
        """
        简化版翻译，只返回翻译文本
        
        Args:
            text: 要翻译的文本
            from_lang: 源语言代码
            to_lang: 目标语言代码
            
        Returns:
            Optional[str]: 翻译结果文本，失败时返回None
        """
        result = self.translate(text, from_lang, to_lang)
        if result["success"]:
            return result["result"]["translated"]
        return None
    
    @staticmethod
    def get_api_help_text() -> str:
        """
        获取API申请帮助文本
        
        Returns:
            str: 帮助文本，显示在界面上指导用户
        """
        return


# 使用示例函数（供测试用）
def example_usage_with_input():
    """
    示例用法，展示如何从用户输入获取API密钥
    """
    print("=" * 60)
    print("有道翻译API测试")
    print("=" * 60)
    
    # 模拟用户输入API密钥
    print("\n请在下方输入您的有道翻译API凭证：")
    app_key = input("应用ID (appKey): ").strip()
    app_secret = input("应用密钥 (appSecret): ").strip()
    
    # 创建翻译器实例
    translator = YoudaoTranslator(app_key, app_secret)
    
    # 检查是否设置了凭证
    if not translator.has_credentials():
        print("\n警告：未设置API凭证，翻译功能不可用")
        return
    
    # 测试翻译
    while True:
        print("\n" + "-" * 40)
        text = input("请输入要翻译的文本（输入q退出）: ").strip()
        
        if text.lower() == 'q':
            break
        
        if not text:
            print("翻译文本不能为空")
            continue
        
        # 执行翻译
        print("\n翻译中...")
        result = translator.translate(text, from_lang="auto", to_lang="en")
        
        if result["success"]:
            print(f"\n✓ 翻译成功！")
            print(f"原文: {result['result']['original']}")
            print(f"译文: {result['result']['translated']}")
            if result['result']['phonetic']:
                print(f"音标: {result['result']['phonetic']}")
            if result['result']['explains']:
                print("详细解释:")
                for explain in result['result']['explains']:
                    print(f"  - {explain}")
        else:
            print(f"\n✗ 翻译失败: {result['error']}")


if __name__ == "__main__":
    # 如果直接运行此文件，执行示例
    example_usage_with_input()